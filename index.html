<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>Gravity Sling</title>
  <meta name="theme-color" content="#000000">
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; }
    body { background:#000; color:#e6e6e6; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; overflow: hidden; }
    #game { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; }
    .hud { position: fixed; left: 0; right: 0; top: 0; pointer-events: none; padding: 10px 12px; font-size: 14px; line-height: 1.35; }
    .row { display: flex; gap: 12px; align-items: center; justify-content: space-between; }
    .panel { pointer-events: auto; background: rgba(8,8,10,.65); border: 1px solid rgba(255,255,255,.1); border-radius: 10px; padding: 10px 12px; backdrop-filter: blur(6px); box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .title { font-weight: 700; letter-spacing: .4px; }
    .btns { display:flex; gap:8px; }
    button { pointer-events: auto; background: #14151a; color:#e6e6e6; border:1px solid #2b2f3a; padding:8px 10px; border-radius:10px; font:inherit; cursor:pointer; }
    button:active { transform: translateY(1px); }
    .bar { height: 8px; background:#1a1b20; border:1px solid #2b2f3a; border-radius: 999px; overflow:hidden; width: 180px; }
    .bar>i { display:block; height:100%; background: linear-gradient(90deg,#33e1ff,#8dff7a); width: 0%; }
    .footer { position: fixed; left: 50%; bottom: 10px; transform: translateX(-50%); }
    .help { position: fixed; right: 10px; bottom: 10px; max-width: 520px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#121318; border:1px solid #2b2f3a; padding:2px 6px; border-radius:6px; font-size:12px; }
    a { color: #9bd3ff; text-decoration: none; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud row">
    <div class="panel" id="leftHud">
      <div class="title">Gravity Sling</div>
      <div>Level <span id="level">1</span> Â· Shots <span id="shots">0</span></div>
      <div>Fuel</div>
      <div class="bar"><i id="fuelFill"></i></div>
    </div>
    <div class="panel btns" id="rightHud">
      <button id="btnReset" title="R">Reset</button>
      <button id="btnPrev" title="J">Prev</button>
      <button id="btnNext" title="N">Next</button>
      <button id="btnHelp" title="H">Help</button>
    </div>
  </div>
  <div class="footer panel" id="status"></div>
  <div class="help panel" id="help" style="display:none">
    <div class="title" style="margin-bottom:6px">How to play</div>
    <ul style="margin:0 0 6px 18px; padding:0">
      <li>Drag from the rocket to aim. Release to launch. Dashed line shows a preview.</li>
      <li>Hold <span class="kbd">Space</span> to thrust toward the pointer and spend fuel.</li>
      <li>Win by touching the target planet. Hitting other planets is a crash.</li>
      <li><span class="kbd">R</span> reset level, <span class="kbd">N</span> next, <span class="kbd">J</span> previous, <span class="kbd">P</span> pause.</li>
      <li>Mouse, touch and trackpads work. On touch, hold anywhere to thrust.</li>
    </ul>
    <div style="opacity:.75">Tip: light taps and slings through gravity wells beat brute force.</div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudLevel = document.getElementById('level');
    const hudShots = document.getElementById('shots');
    const fuelFill = document.getElementById('fuelFill');
    const statusEl = document.getElementById('status');

    const btnReset = document.getElementById('btnReset');
    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnHelp = document.getElementById('btnHelp');
    const help = document.getElementById('help');

    let DPR = Math.min(window.devicePixelRatio || 1, 2);
    function resize(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    addEventListener('resize', resize, {passive:true});
    resize();

    // Math helpers
    const TAU = Math.PI * 2;
    const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
    const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
    const lerp = (a,b,t)=>a+(b-a)*t;
    const norm = (x,y)=>{ const m = Math.hypot(x,y)||1; return {x:x/m,y:y/m}; };

    // Camera
    const cam = { x:0, y:0, zoom: 1 };
    function applyCamera(){
      const s = cam.zoom;
      ctx.setTransform(DPR*s,0,0,DPR*s, canvas.width*0.5 - cam.x*DPR*s, canvas.height*0.5 - cam.y*DPR*s);
    }

    // Stars
    const stars = (()=>{
      const arr = [];
      for(let i=0;i<700;i++){
        arr.push({ x:(Math.random()-0.5)*9000, y:(Math.random()-0.5)*6000, r: Math.random()*1.6 + 0.2, a: Math.random()*0.5+0.25 });
      }
      return arr;
    })();

    // Game constants
    const G = 1400;             // universal grav constant for our toy units
    const DT_MAX = 1/60;        // physics step cap
    const PREVIEW_STEPS = 900;  // preview sim steps
    const PREVIEW_DT = 1/90;    // preview time step
    const OUT_LIMIT = 8000;     // if ship is farther than this, consider lost

    // Input
    const input = { down:false, x:0, y:0, wx:0, wy:0, dragging:false, thrust:false };
    canvas.addEventListener('pointerdown', e=>{
      canvas.setPointerCapture(e.pointerId);
      input.down = true; input.dragging=true; setInput(e);
    });
    canvas.addEventListener('pointermove', e=>{ setInput(e); });
    canvas.addEventListener('pointerup', e=>{ input.down=false; input.dragging=false; setInput(e); if(state==='aim'){ launchFromDrag(); } });
    function setInput(e){
      const rect = canvas.getBoundingClientRect();
      input.x = (e.clientX - rect.left);
      input.y = (e.clientY - rect.top);
      // to world
      const s = cam.zoom * DPR;
      input.wx = (input.x*DPR - canvas.width*0.5)/s + cam.x;
      input.wy = (input.y*DPR - canvas.height*0.5)/s + cam.y;
    }

    const keys = {};
    addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; keyControls(e, true); });
    addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; keyControls(e, false); });

    function keyControls(e, isDown){
      const k = e.key.toLowerCase();
      if(k===' ') { input.thrust = isDown; }
      if(!isDown) return;
      if(k==='r') resetLevel();
      if(k==='n') nextLevel();
      if(k==='j') prevLevel();
      if(k==='h') toggleHelp();
      if(k==='p') paused = !paused;
    }

    btnReset.onclick = resetLevel;
    btnNext.onclick = nextLevel;
    btnPrev.onclick = prevLevel;
    btnHelp.onclick = toggleHelp;
    function toggleHelp(){ help.style.display = help.style.display==='none' ? 'block' : 'none'; }

    // Entities
    class Planet{
      constructor(x,y,radius,mass,color,label){
        this.x=x;this.y=y;this.r=radius;this.m=mass;this.c=color||'#4cc9f0';this.label=label||'';
      }
    }
    class Ship{
      constructor(){ this.x=0; this.y=0; this.vx=0; this.vy=0; this.r=6; this.fuelMax=100; this.fuel=100; this.alive=true; this.launched=false; this.trail=[]; }
    }

    // Levels
    const levels = [
      // Level 1: learn to aim
      { start:0, target:1, planets:[
          new Planet(-220, 0, 60, 2.2e6, '#5ee37a','Start'),
          new Planet( 260, 0, 70, 3.0e6, '#f0a54c','Target'),
          new Planet(0, -220, 22, 2.2e5, '#9b9bff')
        ]},
      // Level 2: gentle sling
      { start:0, target:2, planets:[
          new Planet(-300, -60, 60, 2.2e6, '#5ee37a','Start'),
          new Planet(  40,   0, 40, 9.0e5, '#9b9bff'),
          new Planet( 420,  80, 80, 4.0e6, '#f0a54c','Target')
        ]},
      // Level 3: thread the gap
      { start:0, target:3, planets:[
          new Planet(-340, 180, 65, 2.6e6, '#5ee37a','Start'),
          new Planet( -30,  20, 55, 2.0e6, '#8492ff'),
          new Planet( 160, -40, 45, 1.7e6, '#8492ff'),
          new Planet( 520, 120, 85, 4.6e6, '#f0a54c','Target')
        ]},
      // Level 4: sling around a giant
      { start:1, target:2, planets:[
          new Planet(-460, -40, 45, 1.7e6, '#5ee37a','Start'),
          new Planet(  20,   0,120, 1.3e7, '#67e8f9','Giant'),
          new Planet( 540,  40, 70, 3.4e6, '#f0a54c','Target')
        ]},
      // Level 5: two moons
      { start:0, target:3, planets:[
          new Planet(-420,  30, 60, 2.5e6, '#5ee37a','Start'),
          new Planet( -40, -80, 35, 8.5e5, '#9b9bff'),
          new Planet(  60, 140, 40, 9.0e5, '#9b9bff'),
          new Planet( 520, -60, 80, 4.0e6, '#f0a54c','Target')
        ]},
      // Level 6: long ride
      { start:0, target:2, planets:[
          new Planet(-500,  0, 60, 2.8e6, '#5ee37a','Start'),
          new Planet( -40, 40, 70, 3.2e6, '#8492ff'),
          new Planet( 720, -40, 90, 6.0e6, '#f0a54c','Target')
        ]},
    ];

    // Game state
    let idx = 0;
    let ship = new Ship();
    let state = 'aim'; // aim, flight, won, lost
    let paused = false;
    let shots = 0;
    let preview = [];

    function setupLevel(i){
      idx = clamp(i,0,levels.length-1);
      shots = 0;
      state = 'aim';
      ship = new Ship();
      const L = levels[idx];
      const start = L.planets[L.start];
      // spawn just above the start planet surface on its right side
      const ang = Math.PI*0.02;
      ship.x = start.x + Math.cos(ang)*(start.r + ship.r + 2);
      ship.y = start.y + Math.sin(ang)*(start.r + ship.r + 2);
      ship.vx = 0; ship.vy = 0; ship.fuel = ship.fuelMax;
      cam.x = start.x; cam.y = start.y; cam.zoom = 1.0;
      updateHUD();
      statusEl.textContent = 'Drag to aim. Touch the target planet to win.';
      computePreview();
    }

    function updateHUD(){
      hudLevel.textContent = (idx+1).toString();
      hudShots.textContent = shots.toString();
      const pct = 100 * (ship.fuel/ship.fuelMax);
      fuelFill.style.width = pct.toFixed(1)+'%';
    }

    function resetLevel(){ setupLevel(idx); }
    function nextLevel(){ setupLevel(Math.min(idx+1, levels.length-1)); }
    function prevLevel(){ setupLevel(Math.max(idx-1, 0)); }

    function launchFromDrag(){
      if(state!=='aim') return;
      const v = aimVector();
      const speed = clamp(Math.hypot(v.x, v.y), 0, 320);
      ship.vx = v.x; ship.vy = v.y;
      ship.launched = true; state = 'flight'; shots++; updateHUD();
      statusEl.textContent = 'Flight. Hold Space to thrust toward the pointer.';
    }

    function aimVector(){
      // drag direction from ship to pointer defines power
      const dx = input.wx - ship.x; const dy = input.wy - ship.y;
      const k = 0.7; // power scale
      return { x: dx * k, y: dy * k };
    }

    function computePreview(){
      preview.length = 0;
      if(state!=='aim') return;
      const L = levels[idx];
      const startPos = {x: ship.x, y: ship.y};
      let vx = aimVector().x, vy = aimVector().y;
      let x = startPos.x, y = startPos.y;
      for(let s=0; s<PREVIEW_STEPS; s++){
        // gravity
        let ax=0, ay=0;
        for(const p of L.planets){
          const dx = p.x - x; const dy = p.y - y; const rr = dx*dx+dy*dy; const d = Math.sqrt(rr);
          const a = G * p.m / (rr + 1e-3);
          ax += a * dx/d; ay += a * dy/d;
          if(d < p.r) { // hit planet
            preview.push({x,y, hit:p});
            return;
          }
        }
        vx += ax * PREVIEW_DT; vy += ay * PREVIEW_DT;
        x += vx * PREVIEW_DT; y += vy * PREVIEW_DT;
        if((x*x + y*y) > OUT_LIMIT*OUT_LIMIT){ preview.push({x,y}); return; }
        preview.push({x,y});
      }
    }

    function physicsStep(dt){
      if(paused) return;
      const L = levels[idx];
      // gravity
      let ax=0, ay=0;
      for(const p of L.planets){
        const dx = p.x - ship.x; const dy = p.y - ship.y; const rr = dx*dx + dy*dy; const d = Math.sqrt(rr);
        if(d < p.r + ship.r){ // collision
          if(p === L.planets[L.target]) { state='won'; statusEl.textContent='Win. Press N for next or R to replay.'; }
          else { state='lost'; statusEl.textContent='Crash. Press R to try again.'; }
          return;
        }
        const a = G * p.m / (rr + 1e-3);
        ax += a * dx/d; ay += a * dy/d;
      }
      // thrust toward pointer if active and fuel remains
      const wantThrust = (input.thrust || (input.down && state==='flight')) && ship.fuel > 0;
      if(wantThrust){
        let tx = input.wx - ship.x, ty = input.wy - ship.y;
        if(Math.hypot(tx,ty) < 1) { tx = ship.vx; ty = ship.vy; }
        const t = norm(tx,ty);
        const THRUST = 420; // accel units per second squared
        ax += THRUST * t.x; ay += THRUST * t.y;
        ship.fuel = Math.max(0, ship.fuel - 18 * dt);
      }
      // integrate
      ship.vx += ax * dt; ship.vy += ay * dt;
      ship.x += ship.vx * dt; ship.y += ship.vy * dt;

      // track trail
      ship.trail.push({x:ship.x, y:ship.y});
      if(ship.trail.length > 250) ship.trail.shift();

      // out of bounds
      if((ship.x*ship.x + ship.y*ship.y) > OUT_LIMIT*OUT_LIMIT){ state='lost'; statusEl.textContent='Lost in space. Press R to reset.'; }
    }

    // Render
    function draw(){
      // camera follows ship or focus start during aim
      const targetX = ship.x, targetY = ship.y;
      const L = levels[idx];
      const t = 0.08;
      cam.x = lerp(cam.x, targetX, t);
      cam.y = lerp(cam.y, targetY, t);
      const speed = Math.hypot(ship.vx, ship.vy);
      const baseZoom = 1.0; const zoom = clamp(1.2 - speed*0.002, 0.6, 1.6);
      cam.zoom = lerp(cam.zoom, state==='aim'?1.1:zoom, 0.07);

      // background
      ctx.setTransform(DPR,0,0,DPR,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // stars parallax
      ctx.save();
      const px = -cam.x*0.15*DPR + canvas.width*0.5;
      const py = -cam.y*0.15*DPR + canvas.height*0.5;
      ctx.translate(px, py);
      ctx.fillStyle = '#ffffff';
      for(const s of stars){ ctx.globalAlpha = s.a; ctx.fillRect(s.x, s.y, s.r, s.r); }
      ctx.restore();

      applyCamera();

      // draw preview
      if(state==='aim' && preview.length>1){
        ctx.save();
        ctx.globalAlpha = 0.65; ctx.strokeStyle = '#7ad3ff'; ctx.setLineDash([6,6]); ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(preview[0].x, preview[0].y);
        for(const p of preview){ ctx.lineTo(p.x, p.y); }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }

      // planets
      for(let i=0;i<L.planets.length;i++){
        const p = L.planets[i];
        // glow
        const grd = ctx.createRadialGradient(p.x, p.y, p.r*0.2, p.x, p.y, p.r*1.4);
        grd.addColorStop(0, p.c+'AA'); grd.addColorStop(1, '#00000000');
        ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(p.x, p.y, p.r*1.4, 0, TAU); ctx.fill();
        // body
        ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, TAU); ctx.fill();
        // labels
        ctx.fillStyle = 'rgba(255,255,255,.8)'; ctx.font = '14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='center';
        if(i===L.start){ ctx.fillText('Start', p.x, p.y - p.r - 10); }
        if(i===L.target){ ctx.fillText('Target', p.x, p.y - p.r - 10); }
      }

      // ship
      ctx.save();
      ctx.translate(ship.x, ship.y);
      const ang = Math.atan2(ship.vy, ship.vx);
      if(state!=='aim'){
        ctx.rotate(ang);
      }
      // flame when thrusting
      const thrusting = (input.thrust || (input.down && state==='flight')) && ship.fuel>0;
      if(thrusting){
        ctx.beginPath(); ctx.moveTo(-ship.r-2, 0);
        ctx.lineTo(-ship.r-8 - Math.random()*8, -3);
        ctx.lineTo(-ship.r-8 - Math.random()*8, 3);
        ctx.closePath(); ctx.fillStyle = '#ffdd66'; ctx.fill();
      }
      // body
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.moveTo(ship.r+2, 0); ctx.lineTo(-ship.r, -6); ctx.lineTo(-ship.r, 6); ctx.closePath(); ctx.fill();
      ctx.restore();

      // trail
      if(ship.trail.length>1){
        ctx.save();
        ctx.globalAlpha = 0.5; ctx.strokeStyle = '#99ffee'; ctx.lineWidth = 1.5; ctx.beginPath();
        ctx.moveTo(ship.trail[0].x, ship.trail[0].y);
        for(const p of ship.trail){ ctx.lineTo(p.x, p.y); }
        ctx.stroke(); ctx.restore();
      }

      // aim line
      if(state==='aim' && input.dragging){
        ctx.save(); ctx.strokeStyle = '#ffffff'; ctx.globalAlpha = 0.8; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(ship.x, ship.y); ctx.lineTo(input.wx, input.wy); ctx.stroke(); ctx.restore();
      }

      // cursor indicator for thrusting
      if(state==='flight'){
        ctx.save(); ctx.fillStyle = 'rgba(255,255,255,.12)'; ctx.beginPath(); ctx.arc(input.wx, input.wy, 12/cam.zoom, 0, TAU); ctx.fill(); ctx.restore();
      }
    }

    let last = performance.now();
    function loop(t){
      const dt = Math.min((t - last)/1000, 0.05); last = t;
      let steps = Math.ceil(dt / DT_MAX);
      for(let i=0;i<steps;i++){
        const sdt = dt/steps;
        if(state==='flight') physicsStep(sdt);
      }
      if(state==='aim') computePreview();
      draw();
      updateHUD();
      requestAnimationFrame(loop);
    }

    // start
    setupLevel(0);
    requestAnimationFrame(loop);

  })();
  </script>
</body>
</html>
